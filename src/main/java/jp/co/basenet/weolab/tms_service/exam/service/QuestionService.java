package jp.co.basenet.weolab.tms_service.exam.service;

import jp.co.basenet.weolab.tms_service.exam.dto.Choice;
import jp.co.basenet.weolab.tms_service.exam.dto.Question;
import jp.co.basenet.weolab.tms_service.exam.entity.ChoiceEntity;
import jp.co.basenet.weolab.tms_service.exam.entity.QuestionEntity;
import jp.co.basenet.weolab.tms_service.exam.repository.ChoiceRepository;
import jp.co.basenet.weolab.tms_service.exam.repository.QuestionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * 問題サービス（ビジネスロジック）
 */
@Service
@Transactional
public class QuestionService {

    @Autowired
    private QuestionRepository questionRepository;

    @Autowired
    private ChoiceRepository choiceRepository;

    /**
     * 問題一覧を取得（フィルタ・ページネーション対応）
     */
    @Transactional(readOnly = true)
    public Page<Question> getQuestions(
            String questionId,
            String skill,
            Integer difficultyFrom,
            Integer difficultyTo,
            Boolean isAutoGenerated,
            String keyword,
            int page,
            int size
    ) {
        Pageable pageable = PageRequest.of(page - 1, size); // フロントは1始まり
        Page<QuestionEntity> entities = questionRepository.findWithFilters(
                questionId, skill, difficultyFrom, difficultyTo, isAutoGenerated, keyword, pageable
        );
        return entities.map(this::toDto);
    }

    /**
     * 問題詳細を取得
     */
    @Transactional(readOnly = true)
    public Question getQuestion(String questionId) {
        QuestionEntity entity = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("問題が見つかりません: " + questionId));
        return toDto(entity);
    }

    /**
     * 問題を保存（新規作成・更新の両方対応）
     */
    public Question saveQuestion(Question dto) {
        // IDがなければ新規作成（フロントがUUIDを生成する前提）
        if (dto.getQuestionId() == null || dto.getQuestionId().isEmpty()) {
            dto.setQuestionId(UUID.randomUUID().toString());
        }

        // 問題を保存
        QuestionEntity entity = toEntity(dto);
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());
        QuestionEntity saved = questionRepository.save(entity);

        // 選択肢を一旦全削除（簡易実装）
        choiceRepository.deleteByQuestionId(dto.getQuestionId());

        // 選択肢を再登録
        if (dto.getChoices() != null) {
            for (Choice choiceDto : dto.getChoices()) {
                if (choiceDto.getChoiceId() == null || choiceDto.getChoiceId().isEmpty()) {
                    choiceDto.setChoiceId(UUID.randomUUID().toString());
                }
                ChoiceEntity choiceEntity = new ChoiceEntity();
                choiceEntity.setChoiceId(choiceDto.getChoiceId());
                choiceEntity.setQuestionId(dto.getQuestionId());
                choiceEntity.setChoiceText(choiceDto.getChoiceText());
                choiceEntity.setReason(choiceDto.getReason());
                choiceEntity.setCreatedAt(LocalDateTime.now());
                choiceRepository.save(choiceEntity);
            }
        }

        return getQuestion(dto.getQuestionId()); // 関連データを含めて再取得
    }

    /**
     * 問題を論理削除
     */
    public void deleteQuestion(String questionId) {
        QuestionEntity entity = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("問題が見つかりません: " + questionId));
        entity.setDeletedAt(LocalDateTime.now());
        questionRepository.save(entity);
        // 選択肢は @Where で自動除外されるため、物理削除不要
    }

    // --- ヘルパーメソッド ---

    private Question toDto(QuestionEntity entity) {
        Question dto = new Question();
        dto.setQuestionId(entity.getQuestionId());
        dto.setQuestionText(entity.getQuestionText());
        dto.setDifficulty(entity.getDifficulty());
        dto.setSkill(entity.getSkill());
        dto.setModelAnswerChoiceId(entity.getModelAnswerChoiceId());
        dto.setModelAnswerReason(entity.getModelAnswerReason());
        dto.setIsAutoGenerated(entity.getIsAutoGenerated());
        // 選択肢を取得
        List<ChoiceEntity> choices = questionRepository.findChoicesByQuestionId(entity.getQuestionId());
        dto.setChoices(choices.stream().map(this::toChoiceDto).collect(Collectors.toList()));
        return dto;
    }

    private Choice toChoiceDto(ChoiceEntity entity) {
        Choice dto = new Choice();
        dto.setChoiceId(entity.getChoiceId());
        dto.setChoiceText(entity.getChoiceText());
        dto.setReason(entity.getReason());
        return dto;
    }

    private QuestionEntity toEntity(Question dto) {
        QuestionEntity entity = new QuestionEntity();
        entity.setQuestionId(dto.getQuestionId());
        entity.setQuestionText(dto.getQuestionText());
        entity.setDifficulty(dto.getDifficulty());
        entity.setSkill(dto.getSkill());
        entity.setModelAnswerChoiceId(dto.getModelAnswerChoiceId());
        entity.setModelAnswerReason(dto.getModelAnswerReason());
        entity.setIsAutoGenerated(dto.getIsAutoGenerated() != null ? dto.getIsAutoGenerated() : false);
        return entity;
    }
}